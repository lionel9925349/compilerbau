


package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right), ((Scanner)getScanner()).yytext());
  }

  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }

  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;

non terminal  ArrayAccess arrayAccess;
non terminal  ArrayTypeExpression arrayTypeExpession;
non terminal  AssignStatement assignStatement;
non terminal  BinaryExpression binaryExpression;
non terminal  CallStatement callStatement;
non terminal  CompoundStatement compoudStatement;
non terminal  EmptyStatement emptyStatement;
//expresion
non terminal  GlobalDeclaration globalDeclaration;
non terminal  IfStatement ifStatement;
non terminal  IntLiteral intLiteral;
non terminal  NamedTypeExpression nameTypeExpression;
non terminal  NamedVariable  namedVariable;
//node
non terminal  ParameterDeclaration  parameterDeclaration;
//position
non terminal  ProcedureDeclaration procedureDeclaration;
//programm
non terminal  Statement statementList;
non terminal  TypeDeclaration typeDeclaration;
non terminal  TypeExpression typeExpression;
non terminal  Variable variable;
non terminal  VariableDeclaration variableDeclaration;
non terminal  VariableExpression variableExpression;
non terminal  WhileStatement whileStatement;


non terminal  Expression expr1 ;
non terminal  Expression expr2 ;
non terminal  Expression expr3 ;
non terminal  Expression expr25;
non terminal  Expression expression;
non terminal  deklarationen;
non terminal  anweisungsliste;
non terminal  procedurEingabe;
non terminal  statement;
non terminal  variableDeclarationList;
non terminal  assigmentVariable;
non terminal  argumentList;
non terminal  argument;
non terminal  arguments;
non terminal  parameterDeclarationList;
non terminal  parameterDeclarations;
non terminal  globalDeclarationList;
non terminal  GlobalDeclaration globalDeclarations;


start with program;

program ::= globalDeclarations:gd {: RESULT = new Program(new Position(gdleft,gdright),gd); :};



expr1 ::= expr1:ex1 PLUS expr2:ex2 {:RESULT = new Expression( new Position(ex1left,ex1right)); :}
        | expr1 MINUS expr2
        | expr2 ;
expr2 ::= expr2 STAR expr25
        | expr2 SLASH expr25
        | expr25 ;
expr25 ::= expr3 | MINUS expr3;
expr3 ::= LPAREN expr1  RPAREN
        | variable
        | INTLIT  ;

binaryExpression ::= expr1;
variableExpression ::= expr1;// Fragen
arrayTypeExpession ::= ARRAY: LBRACK INTLIT RBRACK OF typeExpression;


globalDeclarations ::= globalDeclarationList:gdl {: RESULT = gdl; :} | {: RESULT = nill(); :} ;
globalDeclarationList ::= globalDeclaration:gd  globalDeclarationList:gdl {: RESULT = cons(gd, gdl); :}
                        | globalDeclaration:gd {: RESULT = cons(gd, nil()); :};
//    public ProcedureDeclaration(Position position, Identifier name, List<ParameterDeclaration> parameters, List<VariableDeclaration> variables, List<Statement> body) {
globalDeclaration ::= procedureDeclaration:pd
                    | typeDeclaration;


//variable ::= variable LBRACK expr1 RBRACK |IDENT  ;
variable ::= variable:var LBRACK expr1:ex RBRACK {: RESULT = new ArrayAccess ( new Position(varleft,varright),var, ex); :}
            |IDENT:id {: RESULT = new NamedVariable ( new Position(idleft,idright), id ); :};

typeDeclaration ::= TYPE IDENT:id EQ typeExpression:typEx SEMIC {: RESULT = new TypeDeclaration(new Position(idleft,idright),typEx,id );:};
typeExpression ::=  IDENT:id {: RESULT = new NamedTypeExpression(new Position(idleft,idright),id); :}
                    | ARRAY:pos  LBRACK INTLIT:size  RBRACK OF typeExpression:base {: RESULT = new ArrayTypeExpression(new Position(posleft,posright),base,size); :} ;

ifStatement ::= IF LPAREN expression RPAREN statement |
                IF LPAREN expression RPAREN statement ELSE statement ;

statementList ::= statement:s statementList:sl {: RESULT = cons(s, sl); :}| {: RESULT = nil(); :};

statement ::=  assignStatement | callStatement| compoudStatement|SEMIC| ifStatement | whileStatement;

compoudStatement ::= LCURL statementList RCURL;

callStatement ::= IDENT LPAREN arguments RPAREN SEMIC ;
argumentList ::= argument COMMA argumentList |  argument ;
arguments ::=  argumentList | ;
argument ::= expr1 ;

assignStatement ::= variable:var ASGN expr1:ex1 SEMIC {: RESULT = new AssignStatement (new Position(varleft,varright),var,ex1); :};

expression ::= expr1 EQ expr1| expr1 GT expr1 | expr1 GE expr1 | expr1 LE expr1 | expr1 LT expr1 |  expr1 NE expr1 | expr1 ;
whileStatement ::= WHILE LPAREN expression RPAREN LCURL statementList RCURL;

procedureDeclaration ::= PROC IDENT:id LPAREN parameterDeclarations:pardec
                     RPAREN LCURL variableDeclarationList:varDec statementList:state RCURL {: RESULT = new ProcedureDeclaration(new Position(pardecleft,pardecright),id, pardec, varDec, state);:};

parameterDeclarations ::= parameterDeclarationList:parDecL {: RESULT = parDecL; :} | {: RESULT = nill(); :};
parameterDeclarationList ::= parameterDeclaration:parDec COMMA parameterDeclarationList:parDecL {: RESULT = cons(parDec, parDecL); :}
                            | parameterDeclaration:parDec {: RESULT = parDec; :};

parameterDeclaration ::= IDENT COLON IDENT
                        | REF IDENT COLON IDENT ;

//procedurEingabe ::= variableDeclarationList statementList;

variableDeclarationList ::= variableDeclaration variableDeclarationList | {: RESULT = nill(); :} ; // ???


variableDeclaration ::= VAR:var IDENT:id COLON typeExpression: SEMIC;

