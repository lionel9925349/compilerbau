package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right), ((Scanner)getScanner()).yytext());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;

non terminal  ArrayAccess arrayAccess;
non terminal  ArrayTypeExpression arrayTypeExpession;
non terminal  AssignStatement assignStatement;
non terminal  BinaryExpression binaryExpression;
non terminal  CallStatement callStatement;
non terminal  CompoundStatement compoudStatement;
non terminal  EmptyStatement emptyStatement;
//expresion
non terminal  GlobalDeclaration globalDeclaration;
non terminal  IfStatement ifStatement;
non terminal  IntLiteral intLiteral;
non terminal  NamedTypeExpression nameTypeExpression;
non terminal  NamedVariable  namedVariable;
//node
non terminal  ParameterDeclaration  parameterDeclaration;
//position
non terminal  ProcedureDeclaration procedureDeclaration;
//programm
non terminal  Statement statementList;
non terminal  TypeDeclaration typeDeclaration;
non terminal  TypeExpression typeExpression;
non terminal  Variable variable;
non terminal  VariableDeclaration variableDeclaration;
non terminal  VariableExpression variableExpression;
non terminal  WhileStatement whileStatement;


non terminal  Expression expr1 ;
non terminal  expr2 ;
non terminal  expr3 ;
non terminal  expr25;
non terminal  expression;
non terminal  deklarationen;
non terminal  anweisungsliste;
non terminal  procedurEingabe;
non terminal  statement;
non terminal  variableDeclarationList;
non terminal  assigmentVariable;
non terminal  argumentList;
non terminal  argument;
non terminal  arguments;
non terminal  parameterDeclarationList;
non terminal  parameterDeclarations;
non terminal  globalDeclarationList;
non terminal  globalDeclarations;


start with program;

program ::= globalDeclarations;

//lionelTypeDeclaration ::= TYPE IDENT EQ IDENT SEMIC
//typeExpression : := TYPE IDENT EQ ARRAY LBRACK INLIT
// 2*2+4
// 2-2*4+(1+1)

expr1 ::= expr1 PLUS expr2
        | expr1 MINUS expr2
        | expr2 ;
expr2 ::= expr2 STAR expr25
        | expr2 SLASH expr25
        | expr25 ;
expr25 ::= expr3 | MINUS expr3;
expr3 ::= LPAREN expr1  RPAREN | variable | INTLIT  ;

binaryExpression ::= expr1;
variableExpression ::= expr1;// Fragen
arrayTypeExpession ::= ARRAY LBRACK INTLIT RBRACK OF typeExpression;


globalDeclarations ::= globalDeclarationList | ;
globalDeclarationList ::= globalDeclaration  globalDeclarationList | globalDeclaration ;
globalDeclaration ::= procedureDeclaration | typeDeclaration;


variable ::= variable LBRACK expr1 RBRACK |IDENT  ;


typeDeclaration ::= TYPE IDENT EQ typeExpression SEMIC ;
typeExpression ::=  IDENT | ARRAY  LBRACK INTLIT RBRACK OF typeExpression ;

ifStatement ::= IF LPAREN expression RPAREN statement |
                IF LPAREN expression RPAREN statement ELSE statement ;

statementList ::= statement statementList | ;

statement ::=  assignStatement | callStatement| compoudStatement|SEMIC| ifStatement | whileStatement;

compoudStatement ::= LCURL statementList RCURL;

callStatement ::= IDENT LPAREN arguments RPAREN SEMIC ;
argumentList ::= argument COMMA argumentList |  argument ;
arguments ::=  argumentList | ;
argument ::= expr1 ;

assignStatement ::= variable ASGN expr1 SEMIC;

expression ::= expr1 EQ expr1| expr1 GT expr1 | expr1 GE expr1 | expr1 LE expr1 | expr1 LT expr1 |  expr1 NE expr1 | expr1 ;
whileStatement ::= WHILE LPAREN expression RPAREN LCURL statementList RCURL;

procedureDeclaration ::= PROC IDENT LPAREN parameterDeclarations RPAREN LCURL procedurEingabe RCURL;

parameterDeclarations ::= parameterDeclarationList | ;
parameterDeclarationList ::= parameterDeclaration COMMA parameterDeclarationList | parameterDeclaration;
parameterDeclaration ::= IDENT COLON IDENT | REF IDENT COLON IDENT ;

procedurEingabe ::= variableDeclarationList statementList;

variableDeclarationList ::= variableDeclaration variableDeclarationList | ;


variableDeclaration ::= VAR IDENT COLON typeExpression SEMIC;

