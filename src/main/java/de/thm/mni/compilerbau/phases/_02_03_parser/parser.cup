


package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right), ((Scanner)getScanner()).yytext());
  }

  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }

  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;

non terminal  ArrayAccess arrayAccess;
non terminal  ArrayTypeExpression arrayTypeExpession;
non terminal  AssignStatement assignStatement;
non terminal  BinaryExpression binaryExpression;
non terminal  CallStatement callStatement;
non terminal  CompoundStatement compoudStatement;
non terminal  EmptyStatement emptyStatement;
//expresion
non terminal  GlobalDeclaration globalDeclaration;
non terminal  IfStatement ifStatement;
non terminal  IntLiteral intLiteral;
non terminal  NamedTypeExpression nameTypeExpression;
non terminal  NamedVariable  namedVariable;
//node
non terminal  ParameterDeclaration  parameterDeclaration;
//position
non terminal  ProcedureDeclaration procedureDeclaration;
//programm
non terminal  Statement statementList;
non terminal  TypeDeclaration typeDeclaration;
non terminal  TypeExpression typeExpression;
non terminal  Variable variable;
non terminal  VariableDeclaration variableDeclaration;
non terminal  VariableExpression variableExpression;
non terminal  WhileStatement whileStatement;


non terminal  Expression expr1 ;
non terminal  Expression expr2 ;
non terminal  Expression expr3 ;
non terminal  Expression expr25;
non terminal  Expression expression;
non terminal  deklarationen;
non terminal  procedurEingabe;
non terminal  statement;
non terminal  variableDeclarationList;
non terminal  assigmentVariable;
non terminal  argumentList;
non terminal  argument;
non terminal  arguments;
non terminal  List<ParameterDeclaration parameterDeclarationList;
non terminal  parameterDeclarations;
non terminal  List<GlobalDeclaration> globalDeclarationList;
non terminal  GlobalDeclaration globalDeclarations;


start with program;

program ::= globalDeclarations:gd {: RESULT = new Program(new Position(gdleft,gdright),gd); :};



expr1 ::= expr1:lhs PLUS expr2:rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.ADD,lhs,rhs); :}
        | expr1:lhs MINUS expr2:rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.SUB,lhs,rhs); :}
        | expr2:lhs {: RESULT = lhs; :} ;
expr2 ::= expr2:lhs STAR expr25:rhs {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.MUL,lhs,rhs); :}
        | expr2:lhs SLASH expr25:rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.DIV,lhs,rhs); :}
        | expr25:lhs{: RESULT = lhs; :} ;
expr25 ::= expr3:lhs {: RESULT = lhs; :}
        | MINUS:min expr3:rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.SUB,new IntLiteral(new Position(minleft,minright),0),rhs); :};
expr3 ::= LPAREN expr1:lhs  RPAREN {: RESULT = lhs; :}
        | variable: var {: RESULT = var; :}
        | INTLIT:in {: RESULT = new IntLiteral(new Position(intleft,intright),in); :}; //fragen

binaryExpression ::= expr1:exp {: RESULT = exp; :};

variableExpression ::= expr1:exp {: RESULT = exp; :};
arrayTypeExpession ::= ARRAY:pos LBRACK INTLIT:size RBRACK OF typeExpression:typEx {: RESULT = new ArrayTypeExpression (new Position(posleft,posright),typEx,size); :};


globalDeclarations ::= globalDeclarationList:gdl {: RESULT = gdl; :}
                        | {: RESULT = nill(); :} ;
globalDeclarationList ::= globalDeclaration:gd  globalDeclarationList:gdl {: RESULT = cons(gd, gdl); :}
                        | globalDeclaration:gd {: RESULT = cons(gd, nil()); :};

globalDeclaration ::= procedureDeclaration:pd {: RESULT = pd; :}
                    | typeDeclaration:typDec {: RESULT = typDec; :} ;


//variable ::= variable LBRACK expr1 RBRACK |IDENT  ;
variable ::= variable:var LBRACK expr1:ex RBRACK {: RESULT = new ArrayAccess ( new Position(varleft,varright),var, ex); :}
            |IDENT:id {: RESULT = new NamedVariable ( new Position(idleft,idright), id ); :};

typeDeclaration ::= TYPE IDENT:id EQ typeExpression:typEx SEMIC {: RESULT = new TypeDeclaration(new Position(idleft,idright),typEx,id );:};
typeExpression ::=  IDENT:id {: RESULT = new NamedTypeExpression(new Position(idleft,idright),id); :}
                    | ARRAY:pos  LBRACK INTLIT:size  RBRACK OF typeExpression:typEX {: RESULT = new ArrayTypeExpression(new Position(posleft,posright),typEx,size); :} ;

ifStatement ::= IF LPAREN expression:ex RPAREN statement:stat {: RESULT = new IfStatemen(new Position(exleft,exright),ex,stat); :}
              | IF LPAREN expression:ex RPAREN statement:stat ELSE statement:stat {: RESULT = new IfStatement(new Position(exleft,exright),stat,stat); :} ;

statementList ::= statement:stat statementList:statl {: RESULT = cons(stat, statl); :}| {: RESULT = nil(); :};

statement ::=  assignStatement:assg {: RESULT = assg; :}
               | callStatement:call {: RESULT = call; :}
               | compoudStatement:comp {: RESULT = comp; :}
               |SEMIC:sem {: RESULT = new EmptyStatement(new Position(semleft,semright)); :}
               | ifStatement:ifs {: RESULT = ifs; :}
               | whileStatement:whis {: RESULT = whis; :};

compoudStatement ::= LCURL statementList:statl RCURL {: RESULT = new CompoundStatement(new Position(statlleft,statlright), statl); :};

callStatement ::= IDENT:id LPAREN arguments:args RPAREN SEMIC {: RESULT = new CallStatement(new Position(idleft,idright),id,args); :};
argumentList ::= argument:arg COMMA argumentList:argl {: RESULT = cons(arg, argl); :}
                |  argument:arg {: RESULT = arg; :} ;

arguments ::=  argumentList:argL {: RESULT = argL; :}
            | {: RESULT = nill(); :};
argument ::= expr1:exp {: RESULT = exp; :} ;

assignStatement ::= variable:var ASGN expr1:ex1 SEMIC {: RESULT = new AssignStatement (new Position(varleft,varright),var,ex1); :};


expression ::= expr1:lhs EQ expr1:rhs {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.EQU,lhs,rhs); :}
            | expr1:lhs GT expr1:rhs    {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.GRT,lhs,rhs); :}
            | expr1:lhs  GE expr1: rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.GRE,lhs,rhs); :}
            | expr1:lhs LE expr1:rhs   {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.LSE,lhs,rhs); :}
            | expr1:lhs LT expr1:rhs    {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.LST,lhs,rhs); :}
            | expr1:lhs NE expr1:rhs  {: RESULT = BinaryExpression(new Position(lhsleft,lhsright)  ,BinaryExpression.Operator.NEQ,lhs,rhs); :}
            | expr1:lhs {: RESULT = lhs; :} ;


whileStatement ::= WHILE LPAREN expression:exp RPAREN LCURL statementList:stmL RCURL {: RETURN = WhileStatement(new Position(expleft,expright),exp,stmL); :};

procedureDeclaration ::= PROC IDENT:id LPAREN parameterDeclarations:pardec
                     RPAREN LCURL variableDeclarationList:varDec statementList:state RCURL {: RESULT = new ProcedureDeclaration(new Position(pardecleft,pardecright),id, pardec, varDec, state);:};

parameterDeclarations ::= parameterDeclarationList:parDecL {: RESULT = parDecL; :} | {: RESULT = nill(); :};
parameterDeclarationList ::= parameterDeclaration:parDec COMMA parameterDeclarationList:parDecL {: RESULT = cons(parDec, parDecL); :}
                            | parameterDeclaration:parDec {: RESULT = parDec; :};

parameterDeclaration ::= IDENT:id COLON typeExpression:typEx {: RESULT = new ParameterDeclaration(new Position(pleft,pright),id,typEx); :}
                        | REF:ref IDENT COLON typeExpression:typEx {: RESULT = ref,typEx; :};

//procedurEingabe ::= variableDeclarationList statementList;

//R
variableDeclarationList ::= variableDeclaration:varDec variableDeclarationList:varDecL {: RESULT = cons(varDec,varDecL); :}
                          | {: RESULT = nill(); :} ;

//R
variableDeclaration ::= VAR:var IDENT:id COLON typeExpression:typEx SEMIC {: RESULT = new VariableDeclaration(new Position(varleft,varright),id,typEx); :};

